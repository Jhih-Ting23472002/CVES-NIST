/**
 * CVE 優化工具函數
 * 用於 Web Worker 中的純函數優化處理
 */

import { CveRecord } from '../interfaces/nvd-database.interface';
import { 
  OptimizedCveRecord, 
  OptimizedProductInfo, 
  OptimizedVersionRange,
  VersionConstraint,
  CpeExtractedInfo,
  DescriptionExtractedInfo,
  DataExtractionMethod
} from '../interfaces/optimized-storage.interface';
import { 
  PRODUCT_NORMALIZATION_CONFIG, 
  VERSION_RANGE_PARSING_CONFIG,
  DESCRIPTION_PARSING_PATTERNS,
  ECOSYSTEM_DETECTION_RULES,
  CONFIDENCE_SCORE_WEIGHTS
} from '../config/optimization.config';

/**
 * 優化單一 CVE 記錄（純函數版本）
 */
export function optimizeCveRecord(cveRecord: CveRecord): OptimizedCveRecord {
  const dataExtractionMethods: DataExtractionMethod[] = [];
  const optimizedProductInfo: OptimizedProductInfo[] = [];

  // 步驟 1: 優先使用結構化資料
  const structuredProducts = extractFromStructuredData(cveRecord, dataExtractionMethods);
  optimizedProductInfo.push(...structuredProducts);

  // 步驟 2: 備用方案 - 解析非結構化描述
  if (optimizedProductInfo.length === 0 || shouldUseDescriptionFallback(cveRecord)) {
    const descriptionProducts = extractFromDescription(cveRecord, dataExtractionMethods);
    optimizedProductInfo.push(...descriptionProducts);
  }

  // 步驟 3: 產品名稱正規化和去重
  const normalizedProducts = normalizeAndDeduplicateProducts(optimizedProductInfo);

  // 建構優化記錄
  const optimizedRecord: OptimizedCveRecord = {
    ...cveRecord,
    optimizedProductInfo: normalizedProducts,
    dataExtractionMethods,
    processingTimestamp: Date.now()
  };

  // 移除原始的 versionRanges 和 affectedProducts
  delete (optimizedRecord as any).versionRanges;
  delete (optimizedRecord as any).affectedProducts;

  return optimizedRecord;
}

/**
 * 批次優化 CVE 記錄
 */
export function batchOptimizeCveRecords(
  cveRecords: CveRecord[],
  onProgress?: (processed: number, total: number, currentCveId?: string) => void
): OptimizedCveRecord[] {
  const optimizedRecords: OptimizedCveRecord[] = [];
  const total = cveRecords.length;

  for (let i = 0; i < cveRecords.length; i++) {
    const cveRecord = cveRecords[i];
    
    try {
      const optimized = optimizeCveRecord(cveRecord);
      optimizedRecords.push(optimized);
      
      if (onProgress) {
        onProgress(i + 1, total, cveRecord.id);
      }
    } catch (error) {
      console.warn(`[${cveRecord.id}] 優化失敗:`, error);
      
      if (onProgress) {
        onProgress(i + 1, total, cveRecord.id);
      }
    }
  }

  return optimizedRecords;
}

/**
 * 從結構化資料中提取產品資訊
 */
function extractFromStructuredData(
  cveRecord: CveRecord, 
  methods: DataExtractionMethod[]
): OptimizedProductInfo[] {
  const products: OptimizedProductInfo[] = [];
  let extractedProductCount = 0;

  try {
    if (!cveRecord.configurations || cveRecord.configurations.length === 0) {
      methods.push({
        method: 'structured_cpe',
        success: false,
        extractedProductCount: 0,
        confidenceLevel: 'low',
        notes: 'No configurations data available'
      });
      return products;
    }

    // 遍歷 configurations -> nodes -> cpeMatch
    for (const config of cveRecord.configurations) {
      const nodes = config.nodes || [];
      
      for (const node of nodes) {
        const cpeMatches = node.cpeMatch || [];
        
        for (const cpeMatch of cpeMatches) {
          if (cpeMatch.vulnerable === true) {
            const productInfo = extractProductFromCpeMatch(cpeMatch, cveRecord.id);
            if (productInfo) {
              products.push(productInfo);
              extractedProductCount++;
            }
          }
        }
      }
    }

    methods.push({
      method: 'structured_cpe',
      success: extractedProductCount > 0,
      extractedProductCount,
      confidenceLevel: extractedProductCount > 0 ? 'high' : 'low',
      notes: `Extracted from ${cveRecord.configurations.length} configurations`
    });

  } catch (error) {
    methods.push({
      method: 'structured_cpe',
      success: false,
      extractedProductCount: 0,
      confidenceLevel: 'low',
      notes: `Error: ${error instanceof Error ? error.message : String(error)}`
    });
  }

  return products;
}

/**
 * 從單一 CPE 匹配中提取產品資訊
 */
function extractProductFromCpeMatch(cpeMatch: any, cveId: string): OptimizedProductInfo | null {
  try {
    const cpeName = cpeMatch.criteria || cpeMatch.cpe23Uri;
    if (!cpeName) return null;

    const cpeInfo = parseCpeName(cpeName);
    if (!cpeInfo.product) return null;

    const ecosystem = detectEcosystem(cpeInfo);
    const normalizedProductName = normalizeProductName(cpeInfo.product, ecosystem);
    const versionRanges = buildOptimizedVersionRanges(cpeMatch, cpeName);
    const confidenceScore = calculateConfidenceScore({
      source: 'structured_cpe',
      hasVersionConstraints: versionRanges.length > 0,
      productNameQuality: 'exact'
    });
    const aliases = generateProductAliases(cpeInfo.product, ecosystem);

    return {
      productName: normalizedProductName,
      vendor: cpeInfo.vendor,
      ecosystem,
      versionRanges,
      cpeInfo,
      confidenceScore,
      aliases
    };

  } catch (error) {
    return null;
  }
}

/**
 * 從描述中提取產品資訊
 */
function extractFromDescription(
  cveRecord: CveRecord, 
  methods: DataExtractionMethod[]
): OptimizedProductInfo[] {
  const products: OptimizedProductInfo[] = [];
  let extractedProductCount = 0;

  try {
    if (!cveRecord.descriptions || cveRecord.descriptions.length === 0) {
      methods.push({
        method: 'description_regex',
        success: false,
        extractedProductCount: 0,
        confidenceLevel: 'low',
        notes: 'No descriptions available'
      });
      return products;
    }

    const descriptions = cveRecord.descriptions.sort((a, b) => {
      if (a.lang === 'en') return -1;
      if (b.lang === 'en') return 1;
      return 0;
    });

    for (const desc of descriptions) {
      if (!desc.value) continue;

      const extractedProducts = parseDescriptionText(desc.value, desc.lang, cveRecord.id);
      products.push(...extractedProducts);
      extractedProductCount += extractedProducts.length;

      if (desc.lang === 'en' && extractedProducts.length > 0) {
        break;
      }
    }

    methods.push({
      method: 'description_regex',
      success: extractedProductCount > 0,
      extractedProductCount,
      confidenceLevel: extractedProductCount > 0 ? 'medium' : 'low',
      notes: `Processed ${descriptions.length} descriptions`
    });

  } catch (error) {
    methods.push({
      method: 'description_regex',
      success: false,
      extractedProductCount: 0,
      confidenceLevel: 'low',
      notes: `Error: ${error instanceof Error ? error.message : String(error)}`
    });
  }

  return products;
}

/**
 * 解析描述文字
 */
function parseDescriptionText(text: string, language: string, cveId: string): OptimizedProductInfo[] {
  const products: OptimizedProductInfo[] = [];
  const processedProducts = new Set<string>();

  // 使用 affects 模式
  const affectsMatches = extractAffectsPattern(text, language, cveId);
  for (const match of affectsMatches) {
    if (!processedProducts.has(match.productName)) {
      products.push(match);
      processedProducts.add(match.productName);
    }
  }

  // 如果沒有找到，使用通用模式
  if (products.length === 0) {
    const vulnerabilityMatches = extractVulnerabilityPatterns(text, language, cveId);
    for (const match of vulnerabilityMatches) {
      if (!processedProducts.has(match.productName)) {
        products.push(match);
        processedProducts.add(match.productName);
      }
    }
  }

  return products;
}

/**
 * 提取 affects 模式
 */
function extractAffectsPattern(text: string, language: string, cveId: string): OptimizedProductInfo[] {
  const products: OptimizedProductInfo[] = [];
  const pattern = VERSION_RANGE_PARSING_CONFIG.versionRangePatterns.affectsPackagePattern;
  pattern.lastIndex = 0;

  let match;
  while ((match = pattern.exec(text)) !== null) {
    const packageName = match[1].trim();
    const versionText = match[2].trim();

    if (isValidPackageName(packageName)) {
      const productInfo = buildProductInfoFromDescription(
        packageName,
        versionText,
        text,
        language,
        match[0],
        'affectsPackagePattern'
      );

      if (productInfo) {
        products.push(productInfo);
      }
    }
  }

  return products;
}

/**
 * 提取漏洞模式
 */
function extractVulnerabilityPatterns(text: string, language: string, cveId: string): OptimizedProductInfo[] {
  const products: OptimizedProductInfo[] = [];
  
  for (const pattern of DESCRIPTION_PARSING_PATTERNS.vulnerabilityPatterns) {
    pattern.lastIndex = 0;
    
    let match;
    while ((match = pattern.exec(text)) !== null) {
      const packageName = match[1].trim();

      if (isValidPackageName(packageName)) {
        const versionText = findVersionInformationNearby(text, match.index);
        
        const productInfo = buildProductInfoFromDescription(
          packageName,
          versionText,
          text,
          language,
          match[0],
          'vulnerabilityPattern'
        );

        if (productInfo) {
          products.push(productInfo);
        }
      }
    }
  }

  return products;
}

// 輔助函數實作
function parseCpeName(cpeName: string): CpeExtractedInfo {
  if (!cpeName) return {} as CpeExtractedInfo;

  const parts = cpeName.split(':');
  
  if (parts.length >= 5) {
    return {
      cpeName,
      vendor: parts[3] === '*' ? '' : parts[3],
      product: parts[4] === '*' ? '' : parts[4],
      version: parts[5] === '*' ? undefined : parts[5],
      update: parts[6] === '*' ? undefined : parts[6],
      edition: parts[7] === '*' ? undefined : parts[7],
      language: parts[8] === '*' ? undefined : parts[8]
    };
  }
  
  return { cpeName } as CpeExtractedInfo;
}

function buildOptimizedVersionRanges(cpeMatch: any, cpeName: string): OptimizedVersionRange[] {
  const ranges: OptimizedVersionRange[] = [];
  const constraints: VersionConstraint[] = [];

  if (cpeMatch.versionStartIncluding) {
    constraints.push({ type: 'gte', version: cpeMatch.versionStartIncluding });
  }
  if (cpeMatch.versionStartExcluding) {
    constraints.push({ type: 'gt', version: cpeMatch.versionStartExcluding });
  }
  if (cpeMatch.versionEndIncluding) {
    constraints.push({ type: 'lte', version: cpeMatch.versionEndIncluding });
  }
  if (cpeMatch.versionEndExcluding) {
    constraints.push({ type: 'lt', version: cpeMatch.versionEndExcluding });
  }

  if (constraints.length > 0) {
    ranges.push({
      versionConstraints: constraints,
      originalCpeName: cpeName,
      vulnerable: cpeMatch.vulnerable === true,
      source: 'cpe_configuration'
    });
  }

  return ranges;
}

function detectEcosystem(cpeInfo: CpeExtractedInfo): string {
  if (!cpeInfo.vendor && !cpeInfo.product) return 'unknown';
  
  const vendor = (cpeInfo.vendor || '').toLowerCase();
  const product = (cpeInfo.product || '').toLowerCase();
  
  for (const [ecosystem, rules] of Object.entries(ECOSYSTEM_DETECTION_RULES)) {
    for (const indicator of rules.indicators) {
      if (vendor.includes(indicator) || product.includes(indicator)) {
        return ecosystem;
      }
    }
  }
  
  if (vendor === 'nodejs' || product.includes('node') || product.endsWith('_project')) {
    return 'npm';
  }
  
  return 'npm';
}

function normalizeProductName(productName: string, ecosystem: string): string {
  if (!productName) return '';
  
  let normalized = productName.toLowerCase();
  
  for (const pattern of PRODUCT_NORMALIZATION_CONFIG.commonCleanupPatterns) {
    normalized = normalized.replace(pattern, '');
  }
  
  const ecosystemRules = PRODUCT_NORMALIZATION_CONFIG.ecosystemRules[ecosystem];
  if (ecosystemRules) {
    for (const suffix of ecosystemRules.suffixesToRemove) {
      if (normalized.endsWith(suffix)) {
        normalized = normalized.slice(0, -suffix.length);
      }
    }
    
    for (const prefix of ecosystemRules.prefixesToRemove) {
      if (normalized.startsWith(prefix)) {
        normalized = normalized.slice(prefix.length);
      }
    }
  }
  
  const knownMapping = PRODUCT_NORMALIZATION_CONFIG.knownProductMappings[productName.toLowerCase()];
  if (knownMapping) {
    return knownMapping.standardName;
  }
  
  return normalized || productName;
}

function generateProductAliases(productName: string, ecosystem: string): string[] {
  const aliases = new Set<string>();
  aliases.add(productName);
  
  const knownMapping = PRODUCT_NORMALIZATION_CONFIG.knownProductMappings[productName.toLowerCase()];
  if (knownMapping) {
    knownMapping.aliases.forEach(alias => aliases.add(alias));
  }
  
  const ecosystemRules = PRODUCT_NORMALIZATION_CONFIG.ecosystemRules[ecosystem];
  if (ecosystemRules) {
    const variations = ecosystemRules.nameVariations[productName.toLowerCase()];
    if (variations) {
      variations.forEach(variation => aliases.add(variation));
    }
  }
  
  const name = productName.toLowerCase();
  if (name.includes('-')) {
    aliases.add(name.replace(/-/g, '_'));
    aliases.add(name.replace(/-/g, ''));
  }
  
  if (name.includes('_')) {
    aliases.add(name.replace(/_/g, '-'));
    aliases.add(name.replace(/_/g, ''));
  }
  
  return Array.from(aliases).filter(alias => alias !== productName);
}

function calculateConfidenceScore(options: {
  source: 'structured_cpe' | 'description_parsing';
  hasVersionConstraints: boolean;
  productNameQuality: 'exact' | 'alias' | 'fuzzy' | 'partial' | 'heuristic';
}): number {
  const { source, hasVersionConstraints, productNameQuality } = options;
  
  let score = 0;
  
  if (source === 'structured_cpe') {
    score += CONFIDENCE_SCORE_WEIGHTS.dataSource.structuredCpe;
  } else {
    score += CONFIDENCE_SCORE_WEIGHTS.dataSource.descriptionParsing;
  }
  
  const qualityWeight = CONFIDENCE_SCORE_WEIGHTS.matchQuality[productNameQuality + 'Match' as keyof typeof CONFIDENCE_SCORE_WEIGHTS.matchQuality] || 0.5;
  score += qualityWeight * 0.3;
  
  const versionWeight = hasVersionConstraints ? 
    CONFIDENCE_SCORE_WEIGHTS.versionCompleteness.fullRange : 
    CONFIDENCE_SCORE_WEIGHTS.versionCompleteness.noVersion;
  score += versionWeight * 0.3;
  
  return Math.min(1.0, Math.max(0.0, score));
}

function shouldUseDescriptionFallback(cveRecord: CveRecord): boolean {
  return cveRecord.vulnStatus === 'Awaiting Analysis' || 
         !cveRecord.configurations || 
         cveRecord.configurations.length === 0;
}

function normalizeAndDeduplicateProducts(products: OptimizedProductInfo[]): OptimizedProductInfo[] {
  const uniqueProducts = new Map<string, OptimizedProductInfo>();
  
  for (const product of products) {
    const key = `${product.productName}:${product.ecosystem}`;
    
    if (uniqueProducts.has(key)) {
      const existing = uniqueProducts.get(key)!;
      existing.versionRanges.push(...product.versionRanges);
      existing.aliases = Array.from(new Set([...existing.aliases, ...product.aliases]));
      existing.confidenceScore = Math.max(existing.confidenceScore, product.confidenceScore);
    } else {
      uniqueProducts.set(key, product);
    }
  }
  
  return Array.from(uniqueProducts.values());
}

function buildProductInfoFromDescription(
  packageName: string,
  versionText: string,
  sourceText: string,
  language: string,
  matchedText: string,
  patternType: string
): OptimizedProductInfo | null {
  try {
    const cleanedPackageName = cleanPackageName(packageName);
    if (!cleanedPackageName) return null;

    const ecosystem = guessEcosystemFromName(cleanedPackageName);
    const normalizedProductName = normalizeProductName(cleanedPackageName, ecosystem);
    const versionRanges = parseVersionRangeFromText(versionText);

    const descriptionInfo: DescriptionExtractedInfo = {
      sourceText: sourceText.substring(0, 500),
      extractedProductName: packageName,
      extractedVersionText: versionText,
      regexPattern: patternType,
      language
    };

    const confidenceScore = calculateDescriptionConfidenceScore(versionText, matchedText, patternType);
    const aliases = generateProductAliases(cleanedPackageName, ecosystem);

    return {
      productName: normalizedProductName,
      vendor: '',
      ecosystem,
      versionRanges,
      descriptionInfo,
      confidenceScore,
      aliases
    };

  } catch (error) {
    return null;
  }
}

function findVersionInformationNearby(text: string, matchIndex: number): string {
  const contextStart = Math.max(0, matchIndex - 200);
  const contextEnd = Math.min(text.length, matchIndex + 200);
  const context = text.slice(contextStart, contextEnd);

  for (const pattern of DESCRIPTION_PARSING_PATTERNS.versionConstraintPatterns) {
    pattern.lastIndex = 0;
    const match = pattern.exec(context);
    if (match) {
      return match[0].trim();
    }
  }

  return '';
}

function cleanPackageName(packageName: string): string {
  if (!packageName) return '';
  let cleaned = packageName.trim();
  
  for (const pattern of DESCRIPTION_PARSING_PATTERNS.packageNameCleanupPatterns) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  cleaned = cleaned.replace(/[^\w\-@\/\.]/g, '');
  return cleaned;
}

function guessEcosystemFromName(packageName: string): string {
  const name = packageName.toLowerCase();
  
  if (name.startsWith('@')) return 'npm';
  
  for (const [ecosystem, rules] of Object.entries(ECOSYSTEM_DETECTION_RULES)) {
    for (const indicator of rules.indicators) {
      if (name.includes(indicator)) return ecosystem;
    }
  }
  
  if (name.includes('-') || name.includes('js') || name.includes('node')) return 'npm';
  if (name.includes('_') || name.includes('py')) return 'pypi';
  
  return 'npm';
}

function parseVersionRangeFromText(versionText: string): OptimizedVersionRange[] {
  if (!versionText) return [];

  const ranges: OptimizedVersionRange[] = [];
  
  try {
    const constraints = versionText.split(',').map(c => c.trim());
    
    for (const constraint of constraints) {
      const versionConstraints = parseVersionConstraint(constraint);
      if (versionConstraints.length > 0) {
        ranges.push({
          versionConstraints,
          vulnerable: true,
          source: 'description_parsing'
        });
      }
    }
  } catch (error) {
    // Ignore parsing errors
  }

  return ranges;
}

function parseVersionConstraint(constraint: string): VersionConstraint[] {
  const constraints: VersionConstraint[] = [];
  
  const rangeMatch = constraint.match(VERSION_RANGE_PARSING_CONFIG.versionRangePatterns.versionConstraintPatterns.range);
  if (rangeMatch) {
    constraints.push({
      type: 'range',
      version: rangeMatch[1],
      endVersion: rangeMatch[2],
      includeStart: true,
      includeEnd: true
    });
    return constraints;
  }

  const ltMatch = constraint.match(VERSION_RANGE_PARSING_CONFIG.versionRangePatterns.versionConstraintPatterns.lessThan);
  if (ltMatch) {
    constraints.push({ type: 'lt', version: ltMatch[1] });
  }

  const lteMatch = constraint.match(VERSION_RANGE_PARSING_CONFIG.versionRangePatterns.versionConstraintPatterns.lessThanOrEqual);
  if (lteMatch) {
    constraints.push({ type: 'lte', version: lteMatch[1] });
  }

  const gtMatch = constraint.match(VERSION_RANGE_PARSING_CONFIG.versionRangePatterns.versionConstraintPatterns.greaterThan);
  if (gtMatch) {
    constraints.push({ type: 'gt', version: gtMatch[1] });
  }

  const gteMatch = constraint.match(VERSION_RANGE_PARSING_CONFIG.versionRangePatterns.versionConstraintPatterns.greaterThanOrEqual);
  if (gteMatch) {
    constraints.push({ type: 'gte', version: gteMatch[1] });
  }

  const eqMatch = constraint.match(VERSION_RANGE_PARSING_CONFIG.versionRangePatterns.versionConstraintPatterns.exactVersion);
  if (eqMatch) {
    constraints.push({ type: 'eq', version: eqMatch[1] });
  }

  return constraints;
}

function calculateDescriptionConfidenceScore(versionText: string, matchedText: string, patternType: string): number {
  let score = CONFIDENCE_SCORE_WEIGHTS.dataSource.descriptionParsing;

  if (patternType === 'affectsPackagePattern') {
    score += 0.2;
  }

  if (versionText && versionText.length > 0) {
    score += 0.2;
  }

  if (matchedText.length > 20) {
    score += 0.1;
  }

  return Math.min(1.0, Math.max(0.0, score));
}

function isValidPackageName(packageName: string): boolean {
  if (!packageName || packageName.length < 2) return false;
  
  const excludeWords = [
    'this', 'that', 'with', 'from', 'vulnerability', 'issue', 'allows', 'affects', 'version', 'user', 'application'
  ];
  
  if (excludeWords.includes(packageName.toLowerCase())) {
    return false;
  }

  return /^[@\w][\w\-\.\/]*[\w]$/.test(packageName) || /^@[\w\-]+\/[\w\-\.]+$/.test(packageName);
}