import { Injectable } from '@angular/core';
import { 
  OptimizedCveRecord, 
  OptimizedProductInfo, 
  OptimizedVersionRange,
  VersionConstraint,
  CpeExtractedInfo,
  DescriptionExtractedInfo,
  DataExtractionMethod
} from '../interfaces/optimized-storage.interface';
import { CveRecord, VersionRange } from '../interfaces/nvd-database.interface';
import { 
  PRODUCT_NORMALIZATION_CONFIG, 
  VERSION_RANGE_PARSING_CONFIG,
  DESCRIPTION_PARSING_PATTERNS,
  ECOSYSTEM_DETECTION_RULES,
  CONFIDENCE_SCORE_WEIGHTS
} from '../config/optimization.config';

@Injectable({
  providedIn: 'root'
})
export class CveOptimizationService {
  
  constructor() {}

  /**
   * 優化單一 CVE 記錄
   */
  optimizeCveRecord(cveRecord: CveRecord): OptimizedCveRecord {
    const dataExtractionMethods: DataExtractionMethod[] = [];
    const optimizedProductInfo: OptimizedProductInfo[] = [];

    // 步驟 1: 優先使用結構化資料 (cve.configurations)
    const structuredProducts = this.extractFromStructuredData(cveRecord, dataExtractionMethods);
    optimizedProductInfo.push(...structuredProducts);

    // 步驟 2: 備用方案 - 解析非結構化描述
    if (optimizedProductInfo.length === 0 || this.shouldUseDescriptionFallback(cveRecord)) {
      const descriptionProducts = this.extractFromDescription(cveRecord, dataExtractionMethods);
      optimizedProductInfo.push(...descriptionProducts);
    }

    // 步驟 3: 產品名稱正規化和去重
    const normalizedProducts = this.normalizeAndDeduplicateProducts(optimizedProductInfo);

    // 建構優化記錄
    const optimizedRecord: OptimizedCveRecord = {
      ...cveRecord,
      optimizedProductInfo: normalizedProducts,
      dataExtractionMethods,
      processingTimestamp: Date.now()
    };

    // 移除原始的 versionRanges 和 affectedProducts（已被優化格式取代）
    delete (optimizedRecord as any).versionRanges;
    delete (optimizedRecord as any).affectedProducts;

    return optimizedRecord;
  }

  /**
   * 從結構化資料中提取產品資訊
   */
  private extractFromStructuredData(
    cveRecord: CveRecord, 
    methods: DataExtractionMethod[]
  ): OptimizedProductInfo[] {
    const products: OptimizedProductInfo[] = [];
    let extractedProductCount = 0;

    try {
      if (!cveRecord.configurations || cveRecord.configurations.length === 0) {
        methods.push({
          method: 'structured_cpe',
          success: false,
          extractedProductCount: 0,
          confidenceLevel: 'low',
          notes: 'No configurations data available'
        });
        return products;
      }

      console.log(`[CVE ${cveRecord.id}] 開始從結構化資料提取產品資訊`);

      // 遍歷 configurations -> nodes -> cpeMatch
      for (const config of cveRecord.configurations) {
        const nodes = config.nodes || [];
        
        for (const node of nodes) {
          const cpeMatches = node.cpeMatch || [];
          
          for (const cpeMatch of cpeMatches) {
            // 僅處理 vulnerable = true 的 CPE 記錄
            if (cpeMatch.vulnerable === true) {
              const productInfo = this.extractProductFromCpeMatch(cpeMatch, cveRecord.id);
              if (productInfo) {
                products.push(productInfo);
                extractedProductCount++;
              }
            }
          }
        }
      }

      methods.push({
        method: 'structured_cpe',
        success: extractedProductCount > 0,
        extractedProductCount,
        confidenceLevel: extractedProductCount > 0 ? 'high' : 'low',
        notes: `Extracted from ${cveRecord.configurations.length} configurations`
      });

      console.log(`[CVE ${cveRecord.id}] 從結構化資料提取了 ${extractedProductCount} 個產品`);

    } catch (error) {
      console.warn(`[CVE ${cveRecord.id}] 結構化資料提取失敗:`, error);
      methods.push({
        method: 'structured_cpe',
        success: false,
        extractedProductCount: 0,
        confidenceLevel: 'low',
        notes: `Error: ${error instanceof Error ? error.message : String(error)}`
      });
    }

    return products;
  }

  /**
   * 從單一 CPE 匹配中提取產品資訊
   */
  private extractProductFromCpeMatch(cpeMatch: any, cveId: string): OptimizedProductInfo | null {
    try {
      const cpeName = cpeMatch.criteria || cpeMatch.cpe23Uri;
      if (!cpeName) return null;

      // 解析 CPE 名稱
      const cpeInfo = this.parseCpeName(cpeName);
      if (!cpeInfo.product) return null;

      console.log(`[CVE ${cveId}] 處理 CPE: ${cpeName}`);

      // 檢測生態系統
      const ecosystem = this.detectEcosystem(cpeInfo);

      // 正規化產品名稱
      const normalizedProductName = this.normalizeProductName(cpeInfo.product, ecosystem);

      // 建構版本範圍
      const versionRanges = this.buildOptimizedVersionRanges(cpeMatch, cpeName);

      // 計算信心分數
      const confidenceScore = this.calculateConfidenceScore({
        source: 'structured_cpe',
        hasVersionConstraints: versionRanges.length > 0,
        productNameQuality: 'exact'
      });

      // 產生別名
      const aliases = this.generateProductAliases(cpeInfo.product, ecosystem);

      return {
        productName: normalizedProductName,
        vendor: cpeInfo.vendor,
        ecosystem,
        versionRanges,
        cpeInfo,
        confidenceScore,
        aliases
      };

    } catch (error) {
      console.warn(`[CVE ${cveId}] CPE 解析失敗:`, error);
      return null;
    }
  }

  /**
   * 解析 CPE 名稱
   */
  private parseCpeName(cpeName: string): CpeExtractedInfo {
    if (!cpeName) return {} as CpeExtractedInfo;

    // CPE 2.3 格式: cpe:2.3:a:vendor:product:version:update:edition:language:sw_edition:target_sw:target_hw:other
    const parts = cpeName.split(':');
    
    if (parts.length >= 5) {
      return {
        cpeName,
        vendor: parts[3] === '*' ? '' : parts[3],
        product: parts[4] === '*' ? '' : parts[4],
        version: parts[5] === '*' ? undefined : parts[5],
        update: parts[6] === '*' ? undefined : parts[6],
        edition: parts[7] === '*' ? undefined : parts[7],
        language: parts[8] === '*' ? undefined : parts[8]
      };
    }
    
    return { cpeName } as CpeExtractedInfo;
  }

  /**
   * 建構優化的版本範圍
   */
  private buildOptimizedVersionRanges(cpeMatch: any, cpeName: string): OptimizedVersionRange[] {
    const ranges: OptimizedVersionRange[] = [];
    const constraints: VersionConstraint[] = [];

    // 處理各種版本約束
    if (cpeMatch.versionStartIncluding) {
      constraints.push({
        type: 'gte',
        version: cpeMatch.versionStartIncluding
      });
    }

    if (cpeMatch.versionStartExcluding) {
      constraints.push({
        type: 'gt',
        version: cpeMatch.versionStartExcluding
      });
    }

    if (cpeMatch.versionEndIncluding) {
      constraints.push({
        type: 'lte',
        version: cpeMatch.versionEndIncluding
      });
    }

    if (cpeMatch.versionEndExcluding) {
      constraints.push({
        type: 'lt',
        version: cpeMatch.versionEndExcluding
      });
    }

    // 如果有版本約束，建立版本範圍
    if (constraints.length > 0) {
      ranges.push({
        versionConstraints: constraints,
        originalCpeName: cpeName,
        vulnerable: cpeMatch.vulnerable === true,
        source: 'cpe_configuration'
      });
    }

    return ranges;
  }

  /**
   * 檢測生態系統
   */
  private detectEcosystem(cpeInfo: CpeExtractedInfo): string {
    if (!cpeInfo.vendor && !cpeInfo.product) return 'unknown';
    
    const vendor = (cpeInfo.vendor || '').toLowerCase();
    const product = (cpeInfo.product || '').toLowerCase();
    
    // 檢查各個生態系統的指標
    for (const [ecosystem, rules] of Object.entries(ECOSYSTEM_DETECTION_RULES)) {
      for (const indicator of rules.indicators) {
        if (vendor.includes(indicator) || product.includes(indicator)) {
          return ecosystem;
        }
      }
      
      // 檢查前綴和後綴
      for (const prefix of rules.commonPrefixes) {
        if (product.startsWith(prefix)) {
          return ecosystem;
        }
      }
      
      for (const suffix of rules.commonSuffixes) {
        if (product.endsWith(suffix)) {
          return ecosystem;
        }
      }
    }
    
    // 特殊規則
    if (vendor === 'nodejs' || product.includes('node') || product.endsWith('_project')) {
      return 'npm';
    }
    
    if (vendor === 'python' || product.endsWith('-python')) {
      return 'pypi';
    }
    
    if (vendor === 'ruby' || product.endsWith('-ruby')) {
      return 'rubygems';
    }
    
    return 'npm'; // 預設為 npm
  }

  /**
   * 正規化產品名稱
   */
  private normalizeProductName(productName: string, ecosystem: string): string {
    if (!productName) return '';
    
    let normalized = productName.toLowerCase();
    
    // 應用通用清理規則
    for (const pattern of PRODUCT_NORMALIZATION_CONFIG.commonCleanupPatterns) {
      normalized = normalized.replace(pattern, '');
    }
    
    // 應用生態系統特定規則
    const ecosystemRules = PRODUCT_NORMALIZATION_CONFIG.ecosystemRules[ecosystem];
    if (ecosystemRules) {
      // 移除後綴
      for (const suffix of ecosystemRules.suffixesToRemove) {
        if (normalized.endsWith(suffix)) {
          normalized = normalized.slice(0, -suffix.length);
        }
      }
      
      // 移除前綴
      for (const prefix of ecosystemRules.prefixesToRemove) {
        if (normalized.startsWith(prefix)) {
          normalized = normalized.slice(prefix.length);
        }
      }
    }
    
    // 檢查已知映射
    const knownMapping = PRODUCT_NORMALIZATION_CONFIG.knownProductMappings[productName.toLowerCase()];
    if (knownMapping) {
      return knownMapping.standardName;
    }
    
    return normalized || productName;
  }

  /**
   * 產生產品別名
   */
  private generateProductAliases(productName: string, ecosystem: string): string[] {
    const aliases = new Set<string>();
    
    // 加入原始名稱
    aliases.add(productName);
    
    // 檢查已知映射
    const knownMapping = PRODUCT_NORMALIZATION_CONFIG.knownProductMappings[productName.toLowerCase()];
    if (knownMapping) {
      knownMapping.aliases.forEach(alias => aliases.add(alias));
    }
    
    // 檢查生態系統特定變體
    const ecosystemRules = PRODUCT_NORMALIZATION_CONFIG.ecosystemRules[ecosystem];
    if (ecosystemRules) {
      const variations = ecosystemRules.nameVariations[productName.toLowerCase()];
      if (variations) {
        variations.forEach(variation => aliases.add(variation));
      }
    }
    
    // 生成常見變體
    const name = productName.toLowerCase();
    if (name.includes('-')) {
      aliases.add(name.replace(/-/g, '_'));
      aliases.add(name.replace(/-/g, ''));
    }
    
    if (name.includes('_')) {
      aliases.add(name.replace(/_/g, '-'));
      aliases.add(name.replace(/_/g, ''));
    }
    
    return Array.from(aliases).filter(alias => alias !== productName);
  }

  /**
   * 計算信心分數
   */
  private calculateConfidenceScore(options: {
    source: 'structured_cpe' | 'description_parsing';
    hasVersionConstraints: boolean;
    productNameQuality: 'exact' | 'alias' | 'fuzzy' | 'partial' | 'heuristic';
  }): number {
    const { source, hasVersionConstraints, productNameQuality } = options;
    
    // 基礎分數
    let score = 0;
    
    // 資料來源分數
    if (source === 'structured_cpe') {
      score += CONFIDENCE_SCORE_WEIGHTS.dataSource.structuredCpe;
    } else {
      score += CONFIDENCE_SCORE_WEIGHTS.dataSource.descriptionParsing;
    }
    
    // 匹配品質分數
    const qualityWeight = CONFIDENCE_SCORE_WEIGHTS.matchQuality[productNameQuality + 'Match' as keyof typeof CONFIDENCE_SCORE_WEIGHTS.matchQuality] || 0.5;
    score += qualityWeight * 0.3; // 30% 權重給匹配品質
    
    // 版本資訊完整性分數
    const versionWeight = hasVersionConstraints ? 
      CONFIDENCE_SCORE_WEIGHTS.versionCompleteness.fullRange : 
      CONFIDENCE_SCORE_WEIGHTS.versionCompleteness.noVersion;
    score += versionWeight * 0.3; // 30% 權重給版本完整性
    
    return Math.min(1.0, Math.max(0.0, score));
  }

  /**
   * 從描述中提取產品資訊
   */
  private extractFromDescription(
    cveRecord: CveRecord, 
    methods: DataExtractionMethod[]
  ): OptimizedProductInfo[] {
    const products: OptimizedProductInfo[] = [];
    let extractedProductCount = 0;

    try {
      if (!cveRecord.descriptions || cveRecord.descriptions.length === 0) {
        methods.push({
          method: 'description_regex',
          success: false,
          extractedProductCount: 0,
          confidenceLevel: 'low',
          notes: 'No descriptions available'
        });
        return products;
      }

      console.log(`[CVE ${cveRecord.id}] 開始從描述中提取產品資訊`);

      // 處理各語言的描述，優先處理英文
      const descriptions = cveRecord.descriptions.sort((a, b) => {
        if (a.lang === 'en') return -1;
        if (b.lang === 'en') return 1;
        return 0;
      });

      for (const desc of descriptions) {
        if (!desc.value) continue;

        const extractedProducts = this.parseDescriptionText(desc.value, desc.lang, cveRecord.id);
        products.push(...extractedProducts);
        extractedProductCount += extractedProducts.length;

        // 如果已從英文描述中提取到產品，通常不需要處理其他語言
        if (desc.lang === 'en' && extractedProducts.length > 0) {
          break;
        }
      }

      methods.push({
        method: 'description_regex',
        success: extractedProductCount > 0,
        extractedProductCount,
        confidenceLevel: extractedProductCount > 0 ? 'medium' : 'low',
        notes: `Processed ${descriptions.length} descriptions`
      });

      console.log(`[CVE ${cveRecord.id}] 從描述中提取了 ${extractedProductCount} 個產品`);

    } catch (error) {
      console.warn(`[CVE ${cveRecord.id}] 描述解析失敗:`, error);
      methods.push({
        method: 'description_regex',
        success: false,
        extractedProductCount: 0,
        confidenceLevel: 'low',
        notes: `Error: ${error instanceof Error ? error.message : String(error)}`
      });
    }

    return products;
  }

  /**
   * 解析描述文字
   */
  private parseDescriptionText(text: string, language: string, cveId: string): OptimizedProductInfo[] {
    const products: OptimizedProductInfo[] = [];
    const processedProducts = new Set<string>();

    // 步驟 1: 使用複合模式匹配 "affects package: version constraints"
    const affectsMatches = this.extractAffectsPattern(text, language, cveId);
    for (const match of affectsMatches) {
      if (!processedProducts.has(match.productName)) {
        products.push(match);
        processedProducts.add(match.productName);
      }
    }

    // 步驟 2: 如果沒有找到，使用通用漏洞描述模式
    if (products.length === 0) {
      const vulnerabilityMatches = this.extractVulnerabilityPatterns(text, language, cveId);
      for (const match of vulnerabilityMatches) {
        if (!processedProducts.has(match.productName)) {
          products.push(match);
          processedProducts.add(match.productName);
        }
      }
    }

    return products;
  }

  /**
   * 提取 "affects package: version constraints" 模式
   */
  private extractAffectsPattern(text: string, language: string, cveId: string): OptimizedProductInfo[] {
    const products: OptimizedProductInfo[] = [];
    
    // 使用配置中的 affectsPackagePattern
    const pattern = VERSION_RANGE_PARSING_CONFIG.versionRangePatterns.affectsPackagePattern;
    pattern.lastIndex = 0; // 重置正則表達式

    let match;
    while ((match = pattern.exec(text)) !== null) {
      const packageName = match[1].trim();
      const versionText = match[2].trim();

      console.log(`[CVE ${cveId}] 找到套件: ${packageName}, 版本範圍: ${versionText}`);

      if (this.isValidPackageName(packageName)) {
        const productInfo = this.buildProductInfoFromDescription(
          packageName,
          versionText,
          text,
          language,
          match[0],
          'affectsPackagePattern'
        );

        if (productInfo) {
          products.push(productInfo);
        }
      }
    }

    return products;
  }

  /**
   * 提取一般漏洞描述模式
   */
  private extractVulnerabilityPatterns(text: string, language: string, cveId: string): OptimizedProductInfo[] {
    const products: OptimizedProductInfo[] = [];
    
    for (const pattern of DESCRIPTION_PARSING_PATTERNS.vulnerabilityPatterns) {
      pattern.lastIndex = 0; // 重置正則表達式
      
      let match;
      while ((match = pattern.exec(text)) !== null) {
        const packageName = match[1].trim();

        console.log(`[CVE ${cveId}] 找到潛在套件: ${packageName}`);

        if (this.isValidPackageName(packageName)) {
          // 嘗試在文字中尋找版本資訊
          const versionText = this.findVersionInformationNearby(text, match.index);
          
          const productInfo = this.buildProductInfoFromDescription(
            packageName,
            versionText,
            text,
            language,
            match[0],
            'vulnerabilityPattern'
          );

          if (productInfo) {
            products.push(productInfo);
          }
        }
      }
    }

    return products;
  }

  /**
   * 在附近文字中尋找版本資訊
   */
  private findVersionInformationNearby(text: string, matchIndex: number): string {
    // 在匹配位置前後 200 個字符內尋找版本資訊
    const contextStart = Math.max(0, matchIndex - 200);
    const contextEnd = Math.min(text.length, matchIndex + 200);
    const context = text.slice(contextStart, contextEnd);

    // 使用版本約束模式尋找版本資訊
    for (const pattern of DESCRIPTION_PARSING_PATTERNS.versionConstraintPatterns) {
      pattern.lastIndex = 0;
      const match = pattern.exec(context);
      if (match) {
        return match[0].trim();
      }
    }

    return '';
  }

  /**
   * 從描述資訊建構產品資訊
   */
  private buildProductInfoFromDescription(
    packageName: string,
    versionText: string,
    sourceText: string,
    language: string,
    matchedText: string,
    patternType: string
  ): OptimizedProductInfo | null {
    try {
      // 清理產品名稱
      const cleanedPackageName = this.cleanPackageName(packageName);
      if (!cleanedPackageName) return null;

      // 檢測生態系統
      const ecosystem = this.guessEcosystemFromName(cleanedPackageName);
      
      // 正規化產品名稱
      const normalizedProductName = this.normalizeProductName(cleanedPackageName, ecosystem);

      // 解析版本範圍
      const versionRanges = this.parseVersionRangeFromText(versionText);

      // 建構描述提取資訊
      const descriptionInfo: DescriptionExtractedInfo = {
        sourceText: sourceText.substring(0, 500), // 限制長度
        extractedProductName: packageName,
        extractedVersionText: versionText,
        regexPattern: patternType,
        language
      };

      // 計算信心分數
      const confidenceScore = this.calculateDescriptionConfidenceScore(
        versionText,
        matchedText,
        patternType
      );

      // 產生別名
      const aliases = this.generateProductAliases(cleanedPackageName, ecosystem);

      return {
        productName: normalizedProductName,
        vendor: '', // 描述中通常沒有明確的廠商資訊
        ecosystem,
        versionRanges,
        descriptionInfo,
        confidenceScore,
        aliases
      };

    } catch (error) {
      console.warn('建構描述產品資訊失敗:', error);
      return null;
    }
  }

  /**
   * 清理套件名稱
   */
  private cleanPackageName(packageName: string): string {
    if (!packageName) return '';

    let cleaned = packageName.trim();

    // 應用清理模式
    for (const pattern of DESCRIPTION_PARSING_PATTERNS.packageNameCleanupPatterns) {
      cleaned = cleaned.replace(pattern, '');
    }

    // 移除不合理的字符
    cleaned = cleaned.replace(/[^\w\-@\/\.]/g, '');

    return cleaned;
  }

  /**
   * 根據名稱猜測生態系統
   */
  private guessEcosystemFromName(packageName: string): string {
    const name = packageName.toLowerCase();
    
    // 檢查有作用域的 npm 套件
    if (name.startsWith('@')) {
      return 'npm';
    }
    
    // 檢查各個生態系統的指標
    for (const [ecosystem, rules] of Object.entries(ECOSYSTEM_DETECTION_RULES)) {
      // 檢查指標詞
      for (const indicator of rules.indicators) {
        if (name.includes(indicator)) {
          return ecosystem;
        }
      }
      
      // 檢查前綴和後綴
      for (const prefix of rules.commonPrefixes) {
        if (name.startsWith(prefix)) {
          return ecosystem;
        }
      }
      
      for (const suffix of rules.commonSuffixes) {
        if (name.endsWith(suffix)) {
          return ecosystem;
        }
      }
    }
    
    // 預設啟發式判斷
    if (name.includes('-') || name.includes('js') || name.includes('node')) {
      return 'npm';
    }
    
    if (name.includes('_') || name.includes('py')) {
      return 'pypi';
    }
    
    return 'npm'; // 預設
  }

  /**
   * 從文字中解析版本範圍
   */
  private parseVersionRangeFromText(versionText: string): OptimizedVersionRange[] {
    if (!versionText) return [];

    const ranges: OptimizedVersionRange[] = [];
    
    try {
      // 按逗號分割版本約束
      const constraints = versionText.split(',').map(c => c.trim());
      
      for (const constraint of constraints) {
        const versionConstraints = this.parseVersionConstraint(constraint);
        if (versionConstraints.length > 0) {
          ranges.push({
            versionConstraints,
            vulnerable: true,
            source: 'description_parsing'
          });
        }
      }

    } catch (error) {
      console.warn('版本範圍解析失敗:', error);
    }

    return ranges;
  }

  /**
   * 解析單一版本約束
   */
  private parseVersionConstraint(constraint: string): VersionConstraint[] {
    const constraints: VersionConstraint[] = [];
    
    // 範圍模式：1.0.0 - 2.0.0
    const rangeMatch = constraint.match(VERSION_RANGE_PARSING_CONFIG.versionRangePatterns.versionConstraintPatterns.range);
    if (rangeMatch) {
      constraints.push({
        type: 'range',
        version: rangeMatch[1],
        endVersion: rangeMatch[2],
        includeStart: true,
        includeEnd: true
      });
      return constraints;
    }

    // 小於：< 2.5.4
    const ltMatch = constraint.match(VERSION_RANGE_PARSING_CONFIG.versionRangePatterns.versionConstraintPatterns.lessThan);
    if (ltMatch) {
      constraints.push({
        type: 'lt',
        version: ltMatch[1]
      });
    }

    // 小於等於：<= 2.5.4
    const lteMatch = constraint.match(VERSION_RANGE_PARSING_CONFIG.versionRangePatterns.versionConstraintPatterns.lessThanOrEqual);
    if (lteMatch) {
      constraints.push({
        type: 'lte',
        version: lteMatch[1]
      });
    }

    // 大於：> 1.0.0
    const gtMatch = constraint.match(VERSION_RANGE_PARSING_CONFIG.versionRangePatterns.versionConstraintPatterns.greaterThan);
    if (gtMatch) {
      constraints.push({
        type: 'gt',
        version: gtMatch[1]
      });
    }

    // 大於等於：>= 1.0.0
    const gteMatch = constraint.match(VERSION_RANGE_PARSING_CONFIG.versionRangePatterns.versionConstraintPatterns.greaterThanOrEqual);
    if (gteMatch) {
      constraints.push({
        type: 'gte',
        version: gteMatch[1]
      });
    }

    // 確切版本：= 1.2.3
    const eqMatch = constraint.match(VERSION_RANGE_PARSING_CONFIG.versionRangePatterns.versionConstraintPatterns.exactVersion);
    if (eqMatch) {
      constraints.push({
        type: 'eq',
        version: eqMatch[1]
      });
    }

    return constraints;
  }

  /**
   * 計算描述解析的信心分數
   */
  private calculateDescriptionConfidenceScore(
    versionText: string,
    matchedText: string,
    patternType: string
  ): number {
    let score = CONFIDENCE_SCORE_WEIGHTS.dataSource.descriptionParsing;

    // 根據模式類型調整
    if (patternType === 'affectsPackagePattern') {
      score += 0.2; // 更明確的模式有更高分數
    }

    // 根據版本資訊完整性調整
    if (versionText && versionText.length > 0) {
      score += 0.2;
    }

    // 根據匹配文字長度調整（更長的匹配通常更準確）
    if (matchedText.length > 20) {
      score += 0.1;
    }

    return Math.min(1.0, Math.max(0.0, score));
  }

  /**
   * 驗證套件名稱是否合理
   */
  private isValidPackageName(packageName: string): boolean {
    if (!packageName || packageName.length < 2) return false;
    
    // 排除常見的非套件詞彙
    const excludeWords = [
      'this', 'that', 'with', 'from', 'into', 'over', 'under', 'above',
      'through', 'during', 'before', 'after', 'above', 'below', 'up', 'down',
      'out', 'off', 'on', 'over', 'under', 'again', 'further', 'then', 'once',
      'vulnerability', 'issue', 'allows', 'enables', 'permits', 'causes',
      'affects', 'versions', 'version', 'users', 'user', 'application', 'app'
    ];
    
    if (excludeWords.includes(packageName.toLowerCase())) {
      return false;
    }

    // 基本格式檢查
    return /^[@\w][\w\-\.\/]*[\w]$/.test(packageName) || /^@[\w\-]+\/[\w\-\.]+$/.test(packageName);
  }

  /**
   * 判斷是否應該使用描述回退方案
   */
  private shouldUseDescriptionFallback(cveRecord: CveRecord): boolean {
    // 如果 vulnStatus 為 "Awaiting Analysis"，通常 configurations 為空
    return cveRecord.vulnStatus === 'Awaiting Analysis' || 
           !cveRecord.configurations || 
           cveRecord.configurations.length === 0;
  }

  /**
   * 正規化和去重產品資訊
   */
  private normalizeAndDeduplicateProducts(products: OptimizedProductInfo[]): OptimizedProductInfo[] {
    const uniqueProducts = new Map<string, OptimizedProductInfo>();
    
    for (const product of products) {
      const key = `${product.productName}:${product.ecosystem}`;
      
      if (uniqueProducts.has(key)) {
        // 合併相同產品的版本範圍
        const existing = uniqueProducts.get(key)!;
        existing.versionRanges.push(...product.versionRanges);
        existing.aliases = Array.from(new Set([...existing.aliases, ...product.aliases]));
        // 保持較高的信心分數
        existing.confidenceScore = Math.max(existing.confidenceScore, product.confidenceScore);
      } else {
        uniqueProducts.set(key, product);
      }
    }
    
    return Array.from(uniqueProducts.values());
  }
}